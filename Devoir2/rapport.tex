\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{margin=3cm}

\title{Devoir 2}
\author{Dallemagne Brieuc}
\date{28/02/2024}

\begin{document}


\title{Devoir2 - Décomposition LU et conditionnement}

\section{Réponse}
1 - Le conditionnement d'un problème est une mesure de la sensibilité de la solution du problème par rapport à de petits 
changements dans les données du problème. Le conditionnement est défini comme le rapport entre la variation relative de la solution et
 la variation relative des données. Le conditionnement est défini comme suit: 
\begin{equation}
    \kappa = \frac{||\delta x||/||x||}{||\delta b||/||b||}
\end{equation}
où $\delta x$ est la variation de la solution, $\delta b$ est la variation des données, $x$ est la solution et $b$ est les données.
Le conditionnement par rapport aux inputs A et b est défini comme suit:
\begin{equation}
    \kappa = ||A||.||A^{-1}||
\end{equation}
où $||A||$ est la norme de la matrice A et $||A^{-1}||$ est la norme de la matrice inverse de A.
Pour montrer le conditionnement numériquement, on peut utiliser une implémentation de Numpy et la supposer stable.



2 - L'algorithme de décomposition LU (sans pivotage) est implémenté comme suit:
\begin{lstlisting}
    def LU_decomposition(A):
        n = len(A)
        L = np.zeros((n, n))
        U = np.zeros((n, n))
        for i in range(n):
            L[i][i] = 1
            for j in range(i, n):
                U[i][j] = A[i][j] - np.dot(L[i][0:i], U[0:i][j])
            for j in range(i+1, n):
                L[j][i] = (A[j][i] - np.dot(L[j][0:i], U[0:i][i]))/U[i][i]
        return L, U
\end{lstlisting}
La complexité de l'algorithme de décomposition LU est $O(n^3)$.
L'algorithme de décomposition LU est facilement parallélisable car les calculs de chaque ligne de la matrice L et U sont indépendants.
\newpage
3 - Le pivotage n'est pas nécessaire lorsque tous les mineurs principaux de A sont positifs. Ce n'est pas le cas pour les équations normales.
4 - Pour résoudre le problème des moindres carrés, on peut exploiter une propriété des équations normales pour accélérer la décomposition LU.
L'algorithme de décomposition LU avec exploitation de la propriété des équations normales est implémenté comme suit:
\begin{lstlisting}
    def LU_decomposition(A):
        n = len(A)
        L = np.zeros((n, n))
        U = np.zeros((n, n))
        for i in range(n):
            L[i][i] = 1
            for j in range(i, n):
                U[i][j] = A[i][j] - np.dot(L[i][0:i], U[0:i][j])
            for j in range(i+1, n):
                L[j][i] = (A[j][i] - np.dot(L[j][0:i], U[0:i][i]))/U[i][i]
        return L, U
\end{lstlisting}
Le gain en termes d'opérations arithmétiques est de $O(n^3)$.
\end{document}



