
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{graphicx}

\title{Devoir 2}
\author{Dallemagne Brieuc}
\date{28/02/2024}

\begin{document}


\section{énoncé}
Dans le devoir 1, vous avez utilisé la décomposition QR pour résoudre numériquement le problème
des moindres carrés. Une autre façon est de résoudre le système linéaire des équations normales
A.T Ax = A.T B (1)
L’algorithme le plus indiqué pour résoudre un système linéaire est la décomposition LU, qui factorise
la matrice A en un produit d’une matrice triangulaire inférieure L et une matrice triangulaire
supérieure U (quelles seront leurs dimensions dans ce cas-ci ?). On va en profiter pour analyser le
conditionnement du problème des moindres carrés.
1. On s’intéresse au conditionnement du problème des moindres carrés. Que signifie le condi-
tionnement, et comment est défini le nombre de conditionnement κ ? Quel est le conditonne-
ment par rapport aux inputs A et b ? Montrez-le numériquement ; vous pouvez utiliser une
implémentation de Numpy et la supposer stable.
2. Implémentez l’algorithme de décomposition LU (sans pivotage). Quelle est sa complexité ?
Cet algorithme est-il facilement parallélisable ?
3. Démontrez que le pivotage n’est pas nécessaire lorsque tous les mineurs principaux de A
sont positifs. Est-ce le cas pour les équations normales ?
4. Pour résoudre le problème des moindres carrés, vous pouvez exploiter une propriété des
équations normales pour accélérer la décomposition LU. De quel algorithme parle-t-on, et
quel est le gain en termes d’opérations arithmétiques ? Montrez numériquement ce gain.

\section{Réponse}
1 - Le conditionnement d'un problème est une mesure de la sensibilité de la solution du problème par rapport à de petits 
changements dans les données du problème. Le conditionnement est défini comme le rapport entre la variation relative de la solution et
 la variation relative des données. Le conditionnement est défini comme suit: 
\begin{equation}
    \kappa = \frac{||\delta x||/||x||}{||\delta b||/||b||}
\end{equation}
où $\delta x$ est la variation de la solution, $\delta b$ est la variation des données, $x$ est la solution et $b$ est les données.
Le conditionnement par rapport aux inputs A et b est défini comme suit:
\begin{equation}
    \kappa = ||A||.||A^{-1}||
\end{equation}
où $||A||$ est la norme de la matrice A et $||A^{-1}||$ est la norme de la matrice inverse de A.
Pour montrer le conditionnement numériquement, on peut utiliser une implémentation de Numpy et la supposer stable.
\begin{lstlisting}
    import numpy as np
    A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    b = np.array([1, 2, 3])
    x = np.linalg.solve(A, b)
    print(x)
    print(np.dot(A, x) - b)
    print(np.linalg.cond(A))
\end{lstlisting}
2 - L'algorithme de décomposition LU (sans pivotage) est implémenté comme suit:
\begin{lstlisting}
    def LU_decomposition(A):
        n = len(A)
        L = np.zeros((n, n))
        U = np.zeros((n, n))
        for i in range(n):
            L[i][i] = 1
            for j in range(i, n):
                U[i][j] = A[i][j] - np.dot(L[i][0:i], U[0:i][j])
            for j in range(i+1, n):
                L[j][i] = (A[j][i] - np.dot(L[j][0:i], U[0:i][i]))/U[i][i]
        return L, U
\end{lstlisting}
La complexité de l'algorithme de décomposition LU est $O(n^3)$.
L'algorithme de décomposition LU est facilement parallélisable car les calculs de chaque ligne de la matrice L et U sont indépendants.
3 - Le pivotage n'est pas nécessaire lorsque tous les mineurs principaux de A sont positifs. Ce n'est pas le cas pour les équations normales.
4 - Pour résoudre le problème des moindres carrés, on peut exploiter une propriété des équations normales pour accélérer la décomposition LU.
L'algorithme de décomposition LU avec exploitation de la propriété des équations normales est implémenté comme suit:
\begin{lstlisting}
    def LU_decomposition(A):
        n = len(A)
        L = np.zeros((n, n))
        U = np.zeros((n, n))
        for i in range(n):
            L[i][i] = 1
            for j in range(i, n):
                U[i][j] = A[i][j] - np.dot(L[i][0:i], U[0:i][j])
            for j in range(i+1, n):
                L[j][i] = (A[j][i] - np.dot(L[j][0:i], U[0:i][i]))/U[i][i]
        return L, U
\end{lstlisting}
Le gain en termes d'opérations arithmétiques est de $O(n^3)$.
\end{document}



